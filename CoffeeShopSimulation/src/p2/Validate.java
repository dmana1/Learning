package p2;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;


/**
 * Validates a simulation
 */
/**
 * @author Deepthi
 *
 */
public class Validate {
	private static class InvalidSimulationException extends Exception {
		public InvalidSimulationException() { }
	};

	// Helper method for validating the simulation
	private static void check(boolean check,
			String message) throws InvalidSimulationException {
		if (!check) {
			System.err.println("SIMULATION INVALID : "+message);
			throw new Validate.InvalidSimulationException();
		}
	}

	/** 
	 * Validates the given list of events is a valid simulation.
	 * Returns true if the simulation is valid, false otherwise.
	 *
	 * @param events - a list of events generated by the simulation
	 *   in the order they were generated.
	 *
	 * @returns res - whether the simulation was valid or not
	 */
	public static boolean validateSimulation(List<SimulationEvent> events) {
		try {
			check(events.get(0).event == SimulationEvent.EventType.SimulationStarting,
					"Simulation didn't start with initiation event");
			check(events.get(events.size()-1).event == 
					SimulationEvent.EventType.SimulationEnded,
					"Simulation didn't end with termination event");

			/* In P2 you will write validation code for things such as:
				Should not have more eaters than specified
				Should not have more cooks than specified
				The coffee shop capacity should not be exceeded
				The capacity of each machine should not be exceeded
				Eater should not receive order until cook completes it
				Eater should not leave coffee shop until order is received
				Eater should not place more than one order
				Cook should not work on order before it is placed
			 */
			
			//Should not have more eaters than specified
			
			int totNumOfCustomersEntered =0;			  
           for (SimulationEvent e : events) {
                    if (e.event == SimulationEvent.EventType.CustomerEnteredCoffeeShop) {
                    	totNumOfCustomersEntered++;                  
                    }
            }
            check (totNumOfCustomersEntered == events.get(0).simParams[0], "The total number of customers entered is not equal to " + events.get(0).simParams[0]);

            //Should not have more cooks than specified
            int noOfCooksStarted = 0;
            int noOfCooksEnded = 0;
            
            for (SimulationEvent e : events) {
            if (e.event == SimulationEvent.EventType.CookStarting) 
            	noOfCooksStarted++;
            if (e.event == SimulationEvent.EventType.CookEnding) 
            	noOfCooksEnded++;
            }
            check (noOfCooksStarted == events.get(0).simParams[1], "The number of cooks entered is not equal to " + events.get(0).simParams[1]);

            check(noOfCooksStarted == noOfCooksEnded, "The number of cooks entered and left the coffeeshop are not equal");

			//The coffee shop capacity should not be exceeded
            int noOfCustomersInsideCoffeShop = 0;  	
          
            for (SimulationEvent e : events) {
                check(noOfCustomersInsideCoffeShop <= events.get(0).simParams[2], "Customers entered are more than tables");
                    if (e.event == SimulationEvent.EventType.CustomerEnteredCoffeeShop) {
                    	noOfCustomersInsideCoffeShop++; 
                    }
                    if (e.event == SimulationEvent.EventType.CustomerLeavingCoffeeShop) {
                    	noOfCustomersInsideCoffeShop--; 
                    }
            }
           // The capacity of each machine should not be exceeded
    		int currNoOfBurgers = 0;
    		int currNoOfFries = 0;
    		int currNoOfCoffees = 0;
            boolean validNoOfBurgers = true;
    		boolean validNoOfFries = true;
    		boolean validNoOfCoffees = true;
    		// Machine Capacity Test
    		for (SimulationEvent e : events) {
    			if (e.event == SimulationEvent.EventType.MachineStartingFood) {
    				if (e.machine.machineName.equals("Grill")) {
    					currNoOfBurgers++;
    				} else if (e.machine.machineName.equals("Fryer")) {
    					currNoOfFries++;
    				} else if (e.machine.machineName.equals("CoffeeMaker2000")) {
    					currNoOfCoffees++;
    				}
    			}
    			if (e.event == SimulationEvent.EventType.MachineDoneFood) {
    				if (e.machine.machineName.equals("Grill")) {
    					currNoOfBurgers--;
    				} else if (e.machine.machineName.equals("Fryer")) {
    					currNoOfFries--;
    				} else if (e.machine.machineName.equals("CoffeeMaker2000")) {
    					currNoOfCoffees--;
    				}
    			}
    			if (currNoOfBurgers > events.get(0).simParams[3]) {
    				validNoOfBurgers = false;
    			}
    			if (currNoOfFries > events.get(0).simParams[3]) {
    				validNoOfFries = false;
    			}
    			if (currNoOfCoffees > events.get(0).simParams[3]) {
    				validNoOfCoffees = false;
    			}
    		}
    		 check(validNoOfBurgers, "Machine Grill capacity is exceeded");
    		 check(validNoOfFries, "Machine Fryer capcity is exceeded");
    		 check(validNoOfCoffees, "Machine coffee maker capacity is exceeded");
    		 //Eater should not receive order until cook completes it
    	        HashSet<Integer> orderSet = new HashSet<Integer>();

    	        for (SimulationEvent event : events) {
    	            if (event.event == SimulationEvent.EventType.CookCompletedOrder) {
    	            	orderSet.add(event.orderNumber);
    	            }
    	            if (event.event == SimulationEvent.EventType.CustomerReceivedOrder) {
    	              check((orderSet.contains(event.orderNumber)),"Eater received the order befor cook completed it");
    	            }
    	        }
    	        
    	      // Eater should not leave coffee shop until order is received
    	        HashSet<Customer> customerSet = new HashSet<Customer>();
    	        for (SimulationEvent event : events) {
    	            if (event.event == SimulationEvent.EventType.CustomerReceivedOrder) {
    	            	customerSet.add(event.customer);
    	            }
    	            if (event.event == SimulationEvent.EventType.CustomerLeavingCoffeeShop) {
    	              check((customerSet.contains(event.customer)),"Eater left coffee shop before order is received");
    	            }
    	        }
    	        
    	        //Eater should not place more than one order
    	        HashMap<Customer,Integer> customerAndOrders = new HashMap<Customer,Integer>();
    	        for(SimulationEvent event : events){
    	        	if (event.event == SimulationEvent.EventType.CustomerPlacedOrder) {
    	        		if(customerAndOrders.containsKey(event.customer)){
    	        			int noOFOrders = customerAndOrders.get(event.customer);
    	        			check( noOFOrders <= 1, "Eater should not place more than one order");
    	        			
    	        		}
    	        		else{
    	        			 int noOFOrders = 0;
    	        			customerAndOrders.put(event.customer, ++noOFOrders);
    	        		}
    	            }
    	        }
    	        //Cook should not work on order before it is placed
    	        HashSet<Integer> orderSet1 = new HashSet<Integer>();
    	        for (SimulationEvent event : events) {
    	            if (event.event == SimulationEvent.EventType.CustomerPlacedOrder) {
    	            	orderSet1.add(event.orderNumber);
    	            }
    	            if (event.event == SimulationEvent.EventType.CookStartedFood) {
    	              check((orderSet1.contains(event.orderNumber)),"Cook should not work on order before it is placed");
    	            }
    	        }


    	        
			return true;
		} catch (InvalidSimulationException e) {
			return false;
		}
	}
}
